<!doctype html>
<html>
<head>
	<title>on terminal control</title>
	<meta charset="utf-8">
	<link href="../res/elegant.css" rel="stylesheet" type="text/css">
	<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet">
	<style type="text/css">
		body {
			max-width: 40em;
		}
		code {
			display: inline-block;
			background-color: #7C174E;
			font-size: 0.8em;
			padding: 0.3em;
			border-radius: 0.3em;
			text-shadow: 0px 1.2px 0px #2A0017;
			border: 1px solid #2A0017;
			font-family: "Inconsolata", monospace;
		}
		code.listing {
			display: block;
			white-space: pre-wrap;
			padding: 0.5em 1em;
			line-height: 1.2em;
			tab-size: 4;
		}
		code em { color: #e48ad1; }
		.type { color: #FF71DF; font-weight: bold; }
		.pragma { color: #E48AD1; }
		.str { color: #DB99FF; }
		.label { color: #FF6995; font-weight: bold; }
		.comment { color: #E96CB5; font-style: italic; }
	</style>
</head>
<body>
<h3><a href="../index.html">ʞ</a> / essays /</h3>
<h1>everything you ever wanted to know about terminals</h1>
<div class="byline">
	<p><strong>(but were afraid to ask)</strong></p>
	<p>by Lexi Summer Hale</p>
</div>

<p>so here's a short tutorial on ansi escape codes and terminal control, because you philistines won't stop using ncurses and oh my god <em>WHY ARE WE STILL USING NCURSES IT IS THE TWENTY FIRST FUCKING CENTURY</em></p>

<p>the way terminal emulators handle fancy things like color and cursor shape aren't some mysterious opaque black box you can only access through a library. accessing these capabilities is actually extremely simple; they can even be hardcoded into a text file and displayed by <code>cat</code> or <code>less</code>. or even <a href="http://ʞ.cc/ansiglot">curl</a>! the way you do this is with something called <em>ANSI escape sequences.</em></p>

<p>almost all UI changes in a terminal are accomplished through in-band signalling. these signals are triggered with the ASCII/UTF-8 character <strong>‹ESC›</strong> (<code>0x1B</code> or <code>27</code>). it's the same <strong>‹ESC›</strong> character that you send to the terminal when you press the <code>Escape</code> key on your keyboard or a key sequence involving the <code>Alt</code> key. (typing <strong>‹A-c›</strong> for instance sends the characters <strong>‹ESC›</strong> and <strong>‹c›</strong> in very rapid succession; this is why you'll notice a delay in some terminal programs after you press the escape key — it's waiting to try and determine whether the user hit <code>Escape</code> or an alt-key chord.)</p>

<p>the simplest thing we can do with these escapes is to make the text <strong>bold</strong> (or "bright"). we accomplish this by sending the terminal the <strong>‹ESC›</strong> character followed by <code>[1m</code>. <code>[</code> is a character indicating to the terminal what kind of escape we're sending, <code>1</code> indicates bold/bright mode, and <code>m</code> is the control character for formatting escapes.</p>

<p>all text sent after this escape sequence will be bold until we explicitly turn it off again (even if your program terminates). there are two ways we can turn off bright mode: by clearing formatting entirely, using the <code>m</code> formatting command with no arguments or the argument <code>0</code>, or more specifically clearing the bold bit with the <code>21m</code> command. (you'll notice that you can usually turn off modes by prefixing the same number with <code>2</code>.)</p>

<p>in a C program, this might look like the following:</p>

<code class="listing"><span class="pragma">#include</span> <span class="str">&lt;unistd.h&gt;</span>
<span class="pragma">#define</span> szstr(str) str,sizeof(str)
<span class="type">int</span> main() {
	write(1, szstr(<span class="str">"plain text - \x1b[1mbold text\x1b[0m - plain text"</span>));
}
</code>

<p>the <code>\x1b</code> escape here is a C string escape that inserts hex character <code>0x1B</code> (<strong>‹ESC›</strong>) into the string. it's kind of ugly and unreadable if you're not used to reading source with explicit escapes in it. you can make it a lot less horrible with a handful of defines, tho:</p>

<code class="listing"><span class="pragma">#include</span> <span class="str">&lt;unistd.h&gt;</span>
<span class="pragma">#define</span> szstr(str) str,sizeof(str)

<span class="pragma">#define</span>     plain "0" /* or "" */
<span class="pragma">#define</span>        no "2"
<span class="pragma">#define</span>    bright "1"
<span class="pragma">#define</span>       dim "2"
<span class="pragma">#define</span>    italic "3"
<span class="pragma">#define</span> underline "4"
<span class="pragma">#define</span>   reverse "7"
<span class="pragma">#define</span>      with ";"
<span class="pragma">#define</span>  ansi_esc "\x1b"
<span class="pragma">#define</span> fmt(style) ansi_esc "[" style "m"

<span class="type">int</span> main() {
	write(1, szstr(    <span class="str">"plain text - "</span>
		fmt(right)     <span class="str">"bright text"</span>     fmt(no bright) <span class="str">" - "</span>
		fmt(dim)       <span class="str">"dim text"</span>        fmt(no dim)    <span class="str">" - "</span> 
		fmt(italic)    <span class="str">"italic text"</span>     fmt(no italic) <span class="str">" - "</span>
		fmt(reverse)   <span class="str">"reverse video"</span>   fmt(plain)     <span class="str">" - "</span>
		fmt(underline) <span class="str">"underlined text"</span> fmt(no underline) ")
	);
}
</code>

<p>the beauty of this approach is that all the proper sequences are generated at <em>compile time</em>, meaning the compiler turns all that into a single string interpolated with the raw escapes. it offers much more readability for the coder at zero cost to the end user.</p>

<p>but hang on, where's that semicolon coming from? it turns out, ansi escape codes let you specify multiple formats per sequence. you can separate each command with a <code>;</code>. this would allow us to write formatting commands like <code>fmt(underline with bright with no italic)</code>, which translates into <code>\x1b[4;1;23m</code> at compile time.</p>

<p>of course, being able to style text isn't nearly good enough. we also need to be able to color it. there are two components to a color command: what we're trying to change the color of, and what color we want to change it to. both the foreground and background can be given colors separately - despite what ncurses wants you to believe, you do not have to define """color pairs""" with each foreground-background pair you're going to use. this is a ridiculous archaism that nobody in the 21st fucking century should be limited by.</p>

<p>to target the foreground, we send the character <code>3</code> for normal colors or <code>9</code> for bright colors; to target the background, we send <code>4</code> for normal and <code>10</code>. this is then followed by a color code selecting one of the traditional 8 terminal colors.</p>

<p>note that the "bright" here is both the same thing and something different from the "bright" mode we mentioned earlier. while turning on the "bright" mode will automatically shift text it applies to the bright variant of its color <em>if</em> it is set to one of the traditional 8 colors, setting a "bright color" with <code>9</code> or <code>10</code> will not automatically make the text bold.</p>

<code class="listing"><span class="pragma">#include</span> <span class="str">&lt;unistd.h&gt;</span>
<span class="pragma">#define</span> szstr(str) str,sizeof(str)

<span class="pragma">#define</span> fg "3"
<span class="pragma">#define</span> br_fg "9"
<span class="pragma">#define</span> bg "4"
<span class="pragma">#define</span> br_bg "10"
<span class="pragma">#define</span> with ";"
<span class="pragma">#define</span>      plain ""
<span class="pragma">#define</span>      black "0"
<span class="pragma">#define</span>        red "1"
<span class="pragma">#define</span>      green "2"
<span class="pragma">#define</span>     yellow "3"
<span class="pragma">#define</span>       blue "4"
<span class="pragma">#define</span>    magenta "5"
<span class="pragma">#define</span>       cyan "6"
<span class="pragma">#define</span>      white "7"
<span class="pragma">#define</span>   ansi_esc "\x1b"
<span class="pragma">#define</span> fmt(style) ansi_esc "[" style "m"

<span class="type">int</span> main() {
	write(1, szstr(
		<span class="str">"plain text - "</span>
		fmt(fg blue) <span class="str">"blue text"</span> fmt(plain)               <span class="str">" - "</span>
		fmt(br_fg blue) <span class="str">"bright blue text"</span> fmt(plain)     <span class="str">" - "</span>
		fmt(br_bg red) <span class="str">"bright red background"</span> fmt(plain) <span class="str">" - "</span>
		fmt(fg red with br_bg magenta) <span class="str">"hideous red text"</span> fmt(plain))
	);
}
</code>

<p>when we invoke <code>fmt(fg red with br_bg magenta)</code>, this is translated by the compiler into the command string <code>\x1b[31;105m</code>. note that we're using <code>fmt(plain)</code> (<code>\x1b[m</code>) to clear the coloring here; this is because if you try to reset colors with, for instance, <code>fmt(fg black with bg white)</code>, you'll be overriding the preferences of users who have their terminal color schemes set to anything but that exact pair. additionally, if the user happens to have a terminal with a transparent background, a set background color will created ugly colored blocks around text instead of letting whatever's behind the window display correctly.</p>

<p>now, while it is more polite to use the "8+8" colors because they're a color palette the end-user can easily configure (she might prefer more pastel colors than the default harsh pure-color versions, or change the saturation and lightness to better fit with her terminal background), if you're doing anything remotely interesting UI-wise you're going to run up against that limit very quickly. while you can get a bit more mileage by mixing colors with styling commands, if you want to give <em>any</em> configurability to the user in terms of color schemes (as you rightly should), you'll want access to a much broader palette of colors.</p>

<p>to pick from a 256-color palette, we use a slightly different sort of escape: <code>\x1b[38;5;<em>(color)</em>m</code> to set the foreground and <code>\x1b[48;5;<em>(color)</em>m</code> to set the background, where <em>(color)</em> is the palette index we want to address. these escapes are even more unwieldy than the 8+8 color selectors, so it's even more important to have good abstraction.</p>

<code class="listing"><span class="pragma">#include</span> <span class="str">&lt;unistd.h&gt;</span>
<span class="pragma">#define</span> szstr(str) str,sizeof(str)

<span class="pragma">#define</span>       with ";"
<span class="pragma">#define</span>      plain ";"
<span class="pragma">#define</span> wfg(color) "38;5;" #color
<span class="pragma">#define</span> wbg(color) "48;5;" #color
<span class="pragma">#define</span>   ansi_esc "\x1b"
<span class="pragma">#define</span> fmt(style) ansi_esc "[" style "m"

<span class="type">int</span> main() {
	write(1, szstr(<span class="str">"plain text - "</span>
		fmt(wfg(198) with wbg(232))
			<span class="str">"rose text on dark grey"</span>
		fmt(plain) <span class="str">" - "</span>
		
		fmt(wfg(232) with wbg(248))
			<span class="str">"dark grey on light grey"</span>
		fmt(plain) <span class="str">" - "</span>
		
		fmt(wfg(248) with wbg(232))
			<span class="str">"light grey on dark grey"</span>
		fmt(plain))
	);
}
</code>
here, the stanza <code>fmt(wfg(248) with wbg(232))</code> translates into <code>\x1b[38;5;248;48;5;232m</code>. we're hard-coding the numbers here for simplicity but as a rule of thumb, any time you're using 8-bit colors in a terminal, you should <em>always</em> make them configurable by the user.</p>

<p>the opaque-seeming indexes are actually very systemic, and you can calculate which index to use for a particular color with the formula <code>16 + 36 * r + 6 * g + b</code>, where <code>r</code>, <code>g</code>, and <code>b</code> are integers ranging between 0 and 5. indices 232 through 255 are a grayscale ramp from dark (232) to light (255).</p>

<p>of course, this is still pretty restrictive. 8-bit color may have been enough to '90s CD-ROM games on Windows, but it's long past it's expiration date. using true color is much more flexible. we can do this through the escape sequence <code>\x1b[38;2;<em>(r)</em>;<em>(g)</em>;<em>(b)</em>m</code> where each component is an integer between 0 and 255.</p>

<p>sadly, true color isn't supported on many terminals, urxvt tragically included. for this reason, your program should never rely on it, and abstract these settings away to be configured by the user. defaulting to 8-bit color is a good choice, as every reasonable modern terminal has supported it for a long time now.</p>

<p>but, for users of XTerm, kitty, Konsole, and libVTE-based terminal emulators (such as gnome-terminal, mate-terminal, and termite), it's polite to have a 24-bit color mode in place. for example:</p>

<code class="listing"><span class="pragma">#include</span> <span class="str">&lt;stdio.h&gt;</span>
<span class="pragma">#include</span> <span class="str">&lt;stdint.h&gt;</span>
<span class="pragma">#include</span> <span class="str">&lt;stdbool.h&gt;</span>

<span class="type">struct</span> color {
	enum color_mode { trad, trad_bright, b8, b24 } mode;
	union {
		<span class="type">uint8_t</span> color;
		struct { <span class="type">uint8_t</span> r, g, b; };
	}
};
<span class="type">struct</span> style {
	unsigned <span class="type">char</span> bold      : 1;
	unsigned <span class="type">char</span> underline : 1;
	unsigned <span class="type">char</span> italic    : 1;
	unsigned <span class="type">char</span> dim       : 1;
	unsigned <span class="type">char</span> reverse   : 1;
};
<span class="type">struct</span> format {
	struct style style;
	struct color fg, bg;
};

<span class="type">struct</span> format
	fmt_menu = {
		{0, 0, 0, 0, 0},
		{trad, 7},
		{trad, 4}
	},
	fmt_menu_hl = {
		{1, 0, 0, 0, 0},
		{trad_bright, 7},
		{trad_bright, 4},
	};

<span class="type">void</span> apply_color(<span class="type">bool</span> bg, struct color c) {
	switch(c.mode) {
		case trad: printf(<span class="str">"%c%u"</span>, bg ? <span class="str">'4'</span> : <span class="str">'3'</span>, c.color ); break;
		case trad_bright: printf(<span class="str">"%s%u"</span>, bg ? <span class="str">"9"</span> : <span class="str">"10"</span>, c.color ); break;
		case b8: printf(<span class="str">"%c8;5;%u"</span>, bg ? <span class="str">'4'</span> : <span class="str">'3'</span>, c.color); break;
		case b24: printf(<span class="str">"%c8;2;%u;%u;%u"</span>, bg ? <span class="str">'4'</span> : <span class="str">'3'</span>, c.r, c.b, c.g);
	}
}

<span class="type">void</span> fmt(struct format f) {
	printf(<span class="str">"\x1b["</span>);
	f.bold      && printf(<span class="str">";1"</span>);
	f.underline && printf(<span class="str">";4"</span>);
	f.italic    && printf(<span class="str">";3"</span>);
	f.reverse   && printf(<span class="str">";7"</span>);
	f.dim       && printf(<span class="str">";2"</span>);
	
	apply_color(false, f.fg);
	apply_color(true, f.bg);

	printf(<span class="str">"m"</span>);
}

<span class="type">int</span> main() {
	…
	if (is_conf(<span class="str">"style/menu/color"</span>)) {
		if (strcmp(conf(<span class="str">"style/menu/color"</span>, 0), <span class="str">"rgb"</span>) == 0) {
			fmt_menu.mode = b24;
			fmt_menu.r = atoi(conf(<span class="str">"style/menu/color"</span>, 1));
			fmt_menu.g = atoi(conf(<span class="str">"style/menu/color"</span>, 2));
			fmt_menu.b = atoi(conf(<span class="str">"style/menu/color"</span>, 3));
		} else if (atoi(conf(<span class="str">"style/menu/color"</span>, 0)) &gt; 8) {
			fmt_menu.mode = b8;
			fmt_menu.color = atoi(conf(<span class="str">"style/menu/color"</span>, 1));
		} else {
			fmt_menu.color = atoi(conf(<span class="str">"style/menu/color"</span>, 1));
		}
	}
	…
}
</code>

<p>this sort of infrastructure gives you an enormously flexible formatting system that degrades gracefully without tying you to massive, archaic libraries or contaminating the global namespace with hundreds of idiot functions and macros (which is which of course being entirely indistinguishable). </p>

<p>but what if you want more than formatting? what if you want an actual TUI?</p>

<p>depending on the sort of TUI you want, you could actually get away with plain old ASCII. if you're just trying to draw a progress bar, for instance, you can (and should) use the ASCII control character <strong>‹CR›</strong>, "carriage return" (in C, <code>\r</code>):</p>

<code class="listing"><span class="pragma">#include</span> <span class="str">&lt;unistd.h&gt;</span>
<span class="pragma">#include</span> <span class="str">&lt;stdlib.h&gt;</span>
<span class="pragma">#include</span> <span class="str">&lt;stdint.h&gt;</span>
<span class="pragma">#include</span> <span class="str">&lt;time.h&gt;</span>

<span class="pragma">#define</span> barwidth 25
<span class="pragma">#define</span> szstr(str) str,sizeof(str)

typedef <span class="type">uint8_t</span> bar_t;
<span class="type">int</span> main() {
	srand(time(NULL));
	bar_t prmax = -1;
	<span class="type">size_t</span> ratio = prmax / barwidth;
	for(bar_t progress = 0; progress &lt; prmax;) {
		write(1,<span class="str">"\r"</span>, 1);

		<span class="type">size_t</span> barlen = progress / ratio;
		for (<span class="type">size_t</span> i = 0; i &lt; barwidth; ++i) {
			<span class="type">size_t</span> barlen = progress / ratio;
			if (i &lt;= barlen) write(1,szstr(<span class="str">"█"</span>));
						else write(1,szstr(<span class="str">"░"</span>));
		}

		fsync(1); <span class="comment">// otherwise, terminal will only update on newline</span>

		<span class="type">size_t</span> incr = rand() % (prmax / 10);
		if (prmax - progress &lt; incr) break; <span class="comment">// avoid overflow</span>
		progress += incr;
		sleep(1);
	}
}
</code>

<p>of course, if we want to be <em>really</em> fancy, we can adorn the progress bar with ANSI colors using the escape sequences described above. this will be left as an exercise to the reader.</p>

<p>this is sufficient for basic applications, but eventually, we'll get to the point where we actually need to address and paint individual cells of the terminal. or, what if we wanted to size the progress bar dynamically with the size of the terminal window? it's time to break out ANSI escape sequences again.</p>

<p>the first thing you should always do when writing a TUI application is to send the <strong>TI</strong> or <strong>smcup</strong> escape. this notifies the terminal to switch to TUI mode (the "alternate buffer"), protecting the existing buffer so that it won't be overwritten and users can return to it when your application closes.</p>

<p>in ANSI, we achieve this with the sequence <code><strong>‹ESC›</strong>[?47h</code> (or, as a C string, <code>"\x1b[?47h"</code>).</p>

<p>once you've switched to the alternate buffer, the first thing you'll want to do is clear the screen and home the cursor, to clean up any debris previous applications might have left behind. for this, we use the sequence <code><strong>‹ESC›</strong>[2J</code>, which clears the screen and nukes scrollback. (we <em>can't</em> use the terminal reset sequence, <strong>‹ESC›</strong><code>c</code>, because it affects not just the active buffer, but the entire terminal session, and will wreck everything that's currently displayed!)</p>

<p>likewise, just before exit, you need to send the <strong>TE</strong> or <strong>rmcup</strong> escape. this notifies the terminal to switch back to the previous mode. this sequence, as a C string, is <code>"\x1b[?47l"</code>. to be polite, before you send this escape, you should clean up after yourself, clearing scrollback as before.</p>

<p>(<code>h</code> and <code>l</code> in these escapes seem to stand for "high" and "low," meaning essentially "on" and "off" by reference to hardware IO lines, where high current usually corresponds to a 1 bit and low to a 0 bit. in the hardware terminals of the past eon, it's possible program-configurable modes such as this were implemented with discrete IO lines set to a particular voltage; it's also possible the ANSI escape code designers just reached for a handy metaphor in an age where booleans weren't yet in vogue. if anyone happens to find out the actual story behind this, please do let me know)</p>

<p>once we're in the alternate buffer, we can safely start throwing around escape sequences to move the cursor to arbitrary positions. however, before we do this, we need to how how big the terminal actually is so we can lay out the UI appropriately.</p>

<p>it's good form to have a function called <code>resize()</code> or similar that you run on program start and later when the terminal window is resized. while there is a horrible way to do this with ANSI escapes, it's better to just bite the bullet and learn how to use ioctls and termios.</p>

<p>termios is a POSIX interface that lets you discover and set properties of the current terminal. it's kind of an unholy mess, but fortunately, we only need to use a very small corner of it to get the information we need.</p>

<p>we start off by importing the <code>&lt;sys/ioctl.h&gt;</code> header. this gives us the functions and structures we need to set ioctls. termios returns the size of the window in a structure called <code>struct winsize</code>. (far more rational than anything you'd find in ncurses, no?) this struct is populated using the function call <code>ioctl(1, TIOCGWINSZ, &ws)</code> where <code>ws</code> is the name of our struct (and <code>1</code> is the file descriptor for standard output). terminal width and height can then be accessed in the fields <code>ws_col</code> (for width) and <code>ws_row</code> (for height).</p>

<p>of course, we need to keep these values up to date when the terminal size changes. this is why <code>resize()</code> needs to be its own function - it needs to be called whenever our program is sent the <code>SIGWINCH</code> signal. <code>SIGWINCH</code> is automatically sent to child processes by the controlling terminal emulator whenever its window is reshaped.</p>

<p>a full example of these concepts in action:</p>

<code class="listing"><span class="pragma">#include</span> <span class="str">&lt;sys/ioctl.h&gt;</span>;
<span class="pragma">#include</span> <span class="str">&lt;signal.h&gt;</span>;

<span class="type">uint16_t</span> width;
<span class="type">uint16_t</span> height;

<span class="type">void</span> resize(int i) {
	<span class="comment">// spurious argument needed so that the</span>
	<span class="comment">// function signature matches what signal(3) expects</span>

	<span class="type">struct winsize</span> ws;
	ioctl(1, TIOCGWINSZ, &ws);
	width = ws.ws_col;
	height = ws.ws_row;

	<span class="comment">// from here, call a function to repaint the screen</span>
	<span class="comment">// (probably starting with "\x1b[2J")</span>
}

<span class="type">int</span> main(<span class="type">void</span>) {
	signal(SIGWINCH, resize);
	resize(0);

	<span class="comment">// here await user input</span>
}
</code>

<p>throughout all of this, you may have noticed one thing: despite our attempts to create a clean, slick TUI, the cursor itself remains stubbornly onscreen. don't worry, tho; we can fix this.</p>

<p>the escape sequence to show and hide the cursor works much like the one to switch to and from the alternate buffer, except it has the number <code>25</code> instead of <code>47</code>. we can therefore hide the cursor by printing the string <code>"\x1b[?25l"</code> and show it again with the string <code>"\x1b[?25h"</code>.</p>

<p>it's important to track how you're changing the behavior of the terminal, though, and restore it on program exit. otherwise, the user will have to reset the terminal herself, which many don't even know how to do (for the record, it's <code>$ reset</code> or <code>$ echo -ne "\ec"</code>). since you won't necessarily have control over how your program exits, it's important to set an exit handler using the <code>atexit(3)</code> and <code>signal(3)</code> functions. this way, even if the process is terminated with <code>SIGTERM</code> or <code>SIGINT</code>, it will still restore the terminal to its original state.</p>

<p>(it won't due jack shit in case of a <code>SIGKILL</code>, of course, but at that point it's the user's responsibility anyway.)</p>

<p>here's an example of appropriate terminal cleanup:</p>

<code class="listing"><span class="pragma">#include</span> <span class="str">&lt;stdlib.h&gt;</span>
<span class="pragma">#include</span> <span class="str">&lt;unistd.h&gt;</span>
<span class="pragma">#define</span> say(str) write(1,str,sizeof(str))

<span class="type">void</span> cleanup(<span class="type">void</span>) {
	<span class="comment">//clean up the alternate buffer</span>
	say(<span class="str">"\x1bc\x1b[2J"</span>);

	<span class="comment">//switch back to the normal buffer</span>
	say(<span class="str">"\x1b[?47l"</span>);

	<span class="comment">//show the cursor again</span>
	say(<span class="str">"\x1b[?25h"</span>);
}

<span class="type">void</span> cleanup_die(int i) {
	cleanup();
	exit(1);
}

<span class="type">int</span> main(<span class="type">void</span>) {
	<span class="comment">//enter the alternate buffer</span>
	say(<span class="str">"\x1b[?47h"</span>);

	<span class="comment">//register our cleanup function</span>
	atexit(cleanup);
	signal(SIGTERM, cleanup_die);
	signal(SIGINT,  cleanup_die);

	<span class="comment">//clean up the buffer</span>
	say(<span class="str">"\x1b[?47h"</span>);

	<span class="comment">//hide the cursor</span>
	say(<span class="str">"\x1b[?25l"</span>);
	
	sleep(10);

	return 0;
}
</code></pre>

<p>note the strategic placement of the atexit and signal functions. depending on where the program is in its execution when it receives SIGTERM, the cleanup function may be called before anything following it. if these traps were placed at the top of the program, they might be called before the alternate buffer was even opened, wiping out the ordinary buffer and anything the user had there. this is very impolite: we want to make sure that havoc is minimized.</p>

<p>of course, there is still a very small problem: if by some miracle the program is killed after entering the alternate buffer but before the cleanup function is registered, the user could be left stuck in the alternate buffer. to fix this, we would have to register the cleanup function before anything else, and start off the cleanup function by giving the instruction to enter the alternate buffer. this is a NOP is we're already there; if we're not, it protects the user's terminal from the deleterious effects of the following code.</p>

<p>now we've set the stage for our slick ncurses-free TUI, we just need to figure out how to put things on it.</p>

<p>we can move the cursor to an arbitrary position with <code><strong>‹ESC›</strong>[<em>(r)</em>;<em>(c)</em>H</code>. <em>(r)</em> here is the row we want to move to (the first row being 1), and <em>(c)</em> is the target column (also 1-indexed).</p>

<p>there's a number of other control sequences that move the cursor by relative steps, but as a rule, you should always use absolute addressing, as using relative addressing can lead to cumulative errors - and if your program <em>doesn't</em> know the location of the cursor at all times, something is very wrong.</p>

<p>if you actually try this, though, you'll quickly notice a new problem. anything the user types will still appear onscreen, all over your beautiful TUI,  whether or not you want it to. this also moves the cursor as a side effect. this is chaos you don't want in a program, so we need to put an end to it. however, there's no standardized escape code to accomplish this.</p>

<p>in other words, we need to use termios. the <em>ugly</em> side of termios.</p>

<p>termios, unlike libraries you might be used to, doesn't just have functions you can call to set properties. instead, we need to download the entire termios struct for the current terminal into a variable of type <code>struct termios</code>, make our modifications, and then upload it back to the terminal.</p>

<p>to do this, we need to define two of those structs: one to hold our modifications, and one to hold the original state of the program so it can be restored by our cleanup function at exit. to download the struct, we use the function <code>tcgetattr(3)</code>. this function takes two arguments: a file descriptor representing the current terminal (always <code>1</code>, for stdin), and a pointer to a <code>struct termios</code> to write into. as soon as we've populated our struct, before we've made any modifications, we need to copy the unmodified struct into our global-scope "backup" struct.</p>

<p>after that, we can turn off echo. local echo is one of a number of flags encoded in the bitfield <code>c_lflag</code>, identified by the constant ECHO. to disable it, we first invert <code>ECHO</code> with the <code>~</code> bitwise NOT operator, and then bitwise-AND the field by the resulting value.</p>

<p>once we've made our modifications, we can upload them back up with the function <code>tcsetattr(3)</code>. this one takes <em>three</em> arguments. the first is the file descriptor to modify, as usual. the second is a constant controlling when these modifications actually take place - for our purposes, this is always <code>TCSANOW</code>. finally, we give it a pointer to the struct we've modified.</p>

<p>having turned off local echo, we now need to handle it (and line-editing) by hand, printing and deleting characters as the user types them. the problem is, the terminal won't actually <em>tell</em> us the user has typed anything until she hits <strong>‹ENTER›</strong>, making line-editing (or even just seeing what she's typing) impossible. </p>

<p>the reason this happens is something called <em>canonical mode.</em> canonical mode is the normal mode of operation for dumb terminals and terminal emulators. while in canonical mode, terminals will exhibit traditional Unix-y behaviors, like allowing you to type anything at any time, even if nothing is reading from stdin, and only sending text line-by-line as <strong>‹ENTER›</strong> is keyed. remember, unlike DOS, UNIX uses a file/stream metaphor to interact with the terminal: it's just another file, so you can type things in at any time (and they'll be there as soon as a program decides to read from it again).</p>

<p>this doesn't suit our purposes at all, tho. we need DOS-like control over the UI. to achieve this, we need to turn off canonical mode. this is controlled by the <code>ICANON</code> flag, and with it off, we'll be able to read characters keystroke by keystoke.</p>

<code class="listing"><span class="pragma">#include</span> <span class="str">&lt;unistd.h&gt;</span>
<span class="pragma">#include</span> <span class="str">&lt;termios.h&gt;</span>
<span class="pragma">#include</span> <span class="str">&lt;stdlib.h&gt;</span>
<span class="pragma">#define</span> say(str) write(1, str, sizeof(str))

<span class="type">struct termios</span> initial;

<span class="type">void</span> restore(<span class="type">void</span>) {
	tcsetattr(1, TCSANOW, &initial);
}

<span class="type">void</span> terminit(<span class="type">void</span>) {
	<span class="type">struct termios</span> t;
	tcgetattr(1, &t);
	initial = t;
	atexit(restore);
	t.c_lflag &= (~ECHO & ~ICANON);
	tcsetattr(1, TCSANOW, &t);
}

<span class="type">int</span> main(<span class="type">void</span>) {
	terminit();
	for(<span class="type">char</span> buf; buf != <span class="str">'\n'</span> && buf != <span class="str">'\x1b'</span>;) {
		read(1, &buf, 1);
		say(<span class="str">"\ryou pressed "</span>);
		write(1, &buf, 1);
	}
	return 1;
}
</code>

<p>this is the final piece we strictly <em>need</em> to write a TUI. however, for extra credit:</p>

<p>if you're a <code>vim</code> user, you may have noticed that the cursor changes shape depending on what mode you're in (i-beam for insert, block for normal, or underline for replace). we can do this as well, with the DECSCUSR escape sequences.</p>

<p>these sequences start off as usual, with <code><strong>‹ESC›</strong>[</code>. a numeric character then follows, indicating which cursor we want to employ. we then finish the sequence with the command <code>&nbsp;q</code>, a literal space followed by the letter <code>q</code>.</p>

<p>the values we can use are <code>0</code> or <code>1</code> for a blinking block cursor, <code>2</code> for a steady block cursor, <code>3</code> for a blinking underline cursor, <code>4</code> for a steady underline cursor, <code>5</code> for an blinking i-beam cursor, and <code>6</code> for a steady i-beam. </p>

<p>putting this all together, here's example code for an application that uses all these capabilities:</p>

<code class="listing"><span class="pragma">#include</span> <span class="str">&lt;unistd.h&gt;</span>
<span class="pragma">#include</span> <span class="str">&lt;stdint.h&gt;</span>
<span class="pragma">#include</span> <span class="str">&lt;stddef.h&gt;</span>
<span class="pragma">#include</span> <span class="str">&lt;sys/ioctl.h&gt;</span>
<span class="pragma">#include</span> <span class="str">&lt;termios.h&gt;</span>
<span class="pragma">#include</span> <span class="str">&lt;stdlib.h&gt;</span>
<span class="pragma">#include</span> <span class="str">&lt;stdio.h&gt;</span>
<span class="pragma">#include</span> <span class="str">&lt;signal.h&gt;</span>
<span class="pragma">#include</span> <span class="str">&lt;stdbool.h&gt;</span>

<span class="pragma">#define</span>      with ";"
<span class="pragma">#define</span>     plain "0" /* or "" */
<span class="pragma">#define</span>        no "2"
<span class="pragma">#define</span>    bright "1"
<span class="pragma">#define</span>       dim "2"
<span class="pragma">#define</span>    italic "3"
<span class="pragma">#define</span> underline "4"
<span class="pragma">#define</span>   reverse "7"

<span class="pragma">#define</span>        fg "3"
<span class="pragma">#define</span>        bg "4"
<span class="pragma">#define</span>     br_fg "9"
<span class="pragma">#define</span>     br_bg "10"
<span class="pragma">#define</span>     black "0"
<span class="pragma">#define</span>       red "1"
<span class="pragma">#define</span>     green "2"
<span class="pragma">#define</span>    yellow "3"
<span class="pragma">#define</span>      blue "4"
<span class="pragma">#define</span>   magenta "5"
<span class="pragma">#define</span>      cyan "6"
<span class="pragma">#define</span>     white "7"

<span class="pragma">#define</span>    alt_buf "?47"
<span class="pragma">#define</span>       curs "?25"
<span class="pragma">#define</span> term_clear "2J"
<span class="pragma">#define</span> clear_line "2K"
<span class="pragma">#define</span>       high "h"
<span class="pragma">#define</span>        low "l"
<span class="pragma">#define</span>       jump "H"

<span class="pragma">#define</span> esc "\x1b"
<span class="pragma">#define</span> esca esc "["
<span class="pragma">#define</span> wfg "38;5;"
<span class="pragma">#define</span> wbg "48;5;"
<span class="pragma">#define</span> color "m"
<span class="pragma">#define</span> fmt(f) esca f "m"

<span class="pragma">#define</span> say(s) write(1,s,sizeof(s))
<span class="pragma">#define</span> sz(s) (sizeof(s)/sizeof(*s))

<span class="type">struct termios</span> initial;
<span class="type">uint16_t</span> width, height;

<span class="type">uint8_t</span> meter_value = 0;
<span class="type">uint8_t</span> meter_size = 25;
<span class="type">uint8_t</span> meter_color_on = 219;
<span class="type">uint8_t</span> meter_color_off = 162;
<span class="type">bool</span> help_visible = true;

<span class="type">const <span class="type">char</span></span>* instructions[] = {
	<span class="str">"press "</span> fmt(reverse with bright) <span class="str">" i "</span> fmt(plain)
		<span class="str">" to "</span> fmt(underline with fg cyan) <span class="str">"increase the meter value"</span> fmt(plain),
	<span class="str">"press "</span> fmt(reverse with bright) <span class="str">" b "</span> fmt(plain)
		<span class="str">" to "</span> fmt(underline with fg red) <span class="str">"increase the length of the meter"</span> fmt(plain),
	<span class="str">"press "</span> fmt(reverse with bright) <span class="str">" d "</span> fmt(plain)
		<span class="str">" to "</span> fmt(underline with fg yellow) <span class="str">"decrease the meter value"</span> fmt(plain),
	<span class="str">"press "</span> fmt(reverse with bright) <span class="str">" s "</span> fmt(plain)
		<span class="str">" to "</span> fmt(underline with fg green) <span class="str">"decrease the length of the meter"</span> fmt(plain),
	<span class="str">"press "</span> fmt(reverse with bright) <span class="str">" c "</span> fmt(plain)
		<span class="str">" to "</span> fmt(underline with fg blue) <span class="str">"change the filled color"</span> fmt(plain),
	<span class="str">"press "</span> fmt(reverse with bright) <span class="str">" r "</span> fmt(plain)
		<span class="str">" to "</span> fmt(underline with br_fg red) <span class="str">"change the unfilled color"</span> fmt(plain),
	<span class="str">""</span>,
	<span class="str">"press "</span> fmt(reverse with bright) <span class="str">" h "</span> fmt(plain)
		<span class="str">" to "</span> fmt(underline with fg magenta) <span class="str">"toggle this text"</span> fmt(plain),
	<span class="str">"press "</span> fmt(reverse with bright) <span class="str">"ESC"</span> fmt(plain)
		<span class="str">" to "</span> fmt(underline with br_fg cyan) <span class="str">"quit"</span> fmt(plain)
};

<span class="type">size_t</span> textsz(<span class="type">const <span class="type">char</span></span>* str) {
	<span class="comment">//returns size of string without formatting characters</span>
	<span class="type">size_t</span> sz = 0, i = 0;

	<span class="label">count:</span> if (str[i] == 0) return sz;
		else if (str[i] == <span class="str">'\x1b'</span>) goto skip;
		else { ++i; ++sz; goto count; }

	<span class="label">skip:</span> if (str[i] != <span class="str">'m'</span>) {
		++i; goto skip;
	} else goto count;
};

<span class="type">void</span> restore(<span class="type">void</span>) {
	say(
		<span class="comment">//enter alternate buffer if we haven't already</span>
			esca alt_buf high
		
		<span class="comment">//clean up the buffer</span>
			esca term_clear

		<span class="comment">//show the cursor</span>
			esca curs high

		<span class="comment">//return to the main buffer</span>
			esca alt_buf low
	);

	<span class="comment">//restore original termios params</span>
	tcsetattr(1, TCSANOW, &initial);
	
}
<span class="type">void</span> restore_die(int i) {
	restore();
	exit(1);
}

<span class="type">void</span> repaint(<span class="type">void</span>);

<span class="type">void</span> resize(int i) {
	<span class="type">struct winsize</span> ws;
	ioctl(1, TIOCGWINSZ, &ws);
	width = ws.ws_col;
	height = ws.ws_row;
	say(esca term_clear); 
	repaint();
}

<span class="type">void</span> initterm(<span class="type">void</span>) {
	<span class="comment">// since we're using printf here, which doesn't play nicely</span>
	<span class="comment">// with non-canonical mode, we need to turn off buffering.</span>
	setvbuf(stdout, NULL, _IONBF, 0);

	<span class="label">termios:</span> {
		<span class="type">struct termios</span> t;
		tcgetattr(1, &t);
		initial = t;
		t.c_lflag &= (~ECHO & ~ICANON);
		tcsetattr(1, TCSANOW, &t);
	};
	
	atexit(restore);
	signal(SIGTERM, restore_die);
	signal(SIGINT, restore_die);
	
	say (
		esca alt_buf high
		esc term_clear
		esca curs low
	);
}

<span class="type">void</span> repaint(<span class="type">void</span>) {
	const <span class="type">uint16_t</span>
		mx = (width / 2) - (meter_size / 2),
		my = (height / 2) + 1;
	
	if (help_visible) for (<span class="type">size_t</span> i = 0; i &lt; sz(instructions); ++i)
		printf(esca <span class="str">"%u"</span> with <span class="str">"%u"</span> jump fmt(plain) <span class="str">"%s"</span>,
			<span class="comment">// place lines above meter</span>
				my - (1 + (sz(instructions) - i)),
			<span class="comment">// center each line</span>
				(width/2) - (textsz(instructions[i])/2),
			<span class="comment">// print line</span>
				instructions[i]);

	printf(esca <span class="str">"%u"</span> with <span class="str">"%u"</span> jump, my, mx);
	say(esca clear_line);

	for (<span class="type">size_t</span> i = 0; i &lt; meter_size; ++i)
		printf(esca wfg <span class="str">"%u"</span> color <span class="str">"%s"</span>,
			i &lt; meter_value ? meter_color_on : meter_color_off,
			i &lt; meter_value ? <span class="str">"█"</span> : <span class="str">"░"</span>);
}

<span class="type">int</span> main() {
	initterm();
	signal(SIGWINCH, resize);
	resize(0);
	<span class="type">bool</span> dirty = true;
	for (<span class="type">char</span> inkey; inkey != <span class="str">'\x1b'</span>;) {
		if (dirty) { repaint(); dirty = false; }
		read(1,&inkey,1);
		switch(inkey) {
			case <span class="str">'i'</span>:<span class="comment">// increase meter value</span>
				++meter_value; break;
			case <span class="str">'d'</span>:<span class="comment">// decrease meter value</span>
				--meter_value; break;
			case <span class="str">'b'</span>:<span class="comment">// increase meter size</span>
				++meter_size; break;
			case <span class="str">'s'</span>:<span class="comment">// decrease meter size</span>
				--meter_size; break;
			case <span class="str">'c'</span>:<span class="comment">// randomize meter on color</span>
				meter_color_on = rand(); break;
			case <span class="str">'r'</span>:<span class="comment">// randomize meter off color</span>
				meter_color_off = rand(); break;
			case <span class="str">'h'</span>:<span class="comment">// toggle help text</span>
				help_visible =! help_visible;
				say(esca term_clear); break;
			default: goto end;
		}
		dirty = true;
		end:;
	}
}
</code>

<p>that's it for the tutorial. i hope you learned something and will <em>reconsider using fucking ncurses next time</em> because <em>jesus fucking christ</em>.</p>

<p>yes, ncurses supplies features like window-drawing and region invalidation (to avoid terminal flicker) that are much harder to implement yourself. no, you shouldn't <em>have</em> to implement it yourself. there <em>should</em> be a modern library to <em>replace</em> curses using the capabilities outlined here. but i swear to god developers have so completely forgotten <em>how terminals work</em> that i might be one of a handful of people left on earth who actually has the knowledge to, so they all just layer their bullshit on top of ncurses (which should never have survived the '90s) instead and it's ｍａｄｄｅｎｉｎｇ．</p>

<p>my hope is that this tutorial will curtail some of the more egregiously trivial uses of ncurses and provide others with the knowledge needed to implement a 21st-century terminal UI library. because i sure as fuck don't have the energy to.</p>

<p>also, i'm a) a nobody and b) a woman. nothing i wrote would ever gain any traction; any project designed to supplant ncurses needs to come from someone who's actually known to the FOSS community. and a maintainer who isn't a cripple.</p>

<p>you can find <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">a fuller list of ANSI escapes at wikipedia</a>.</p>

<p>oh, and before anyone starts up:</p>

<p>being compatible only with ANSI-capable terminals <em>is a feature, not a bug,</em> go the fuck away. terminfo is a fucking joke. nobody needs to target obscure dumb terminals from 1983 anymore.</p>

<p><em>all sample code in this document is the sole property of the author and is released exclusively under the <a href="https://gnu.org/licenses/agpl.html">GNU AGPLv3</a>.</em></p>
</body>
</html>
